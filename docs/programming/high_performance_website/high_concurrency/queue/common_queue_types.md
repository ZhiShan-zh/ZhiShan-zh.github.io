# 常见的队列类型

# 1 缓存队列

## 1.1 Log4j缓冲区

典型的如Log4j日志缓冲区，当我们使用Log4j记录日志时，可以配置字节缓冲区，字节缓冲区满时，会立即同步到磁盘。Log4j是使用BufferedWriter实现的。此模式不是异步写，在缓冲区满的时候还是会阻塞主线程。如果需要异步模式，则可以使用AsyncAppender，然后通过bufferSize控制日志时间缓冲区大小。

## 1.2 电商大促场景

在电商大促时，此时的系统流量会高于平常流量的几倍甚至几十倍，此时应进行一些特殊的设计来保证系统平稳度过这段时期。而解决的手段很多，一般牺牲业务的强一致性，保证最终一致性即可。

如下图所示，使用缓冲队列应对突发流量时，并不能使处理速度变快，而是使处理速度变平滑，从而不会因瞬间压力太大而压垮应用。

![](https://zhishan-zh.github.io/media/queue_20200508172233.png)

通过缓冲区队列可以实现批量处理、异步处理和平滑流量。

# 2 任务队列

使用任务队列可以将一些不需要与主线程同步执行的任务扔到任务队列进行异步处理。笔者用的最多的是线程池任务队列（默认为LinkedBlockingQueue）和Disruptor任务队列（RingBuffer）。

- 用户注册完成后，将发送邮件/送积分/送优惠券任务仍到任务队列进行异步处理；
- 刷数据时，将任务队列扔到队列异步处理，处理成功后再异步通知用户；
- 删除SKU操作，在用户请求时直接将任务分解并扔到队列进行异步处理，处理成功后异步通知用户；
- 查询聚合时，将多个可并行处理的任务扔到队列，然后等待最慢的一个任务返回。

通过任务队列可以实现异步处理、任务分解/聚合处理。

注：JDK7提供了ExecutorService的新实现ForkJoinPool，其提供的Work-stealing机制，可以更好第提升并发效率。

# 3 消息队列

使用消息队列存储各业务数据，其他系统更具需要订阅即可。

常见的订阅模式是：

- 点对点：一个消息只有一个消费者；
- 发布订阅：一个消息可以有多个消费者（常用）。

比如，修改商品数据、变更订单状态时，都应该将变更信息发送到消息队列，如果其他系统有需要，则直接订阅该消息队列即可。

通过消息队列可以实现异步处理、系统解偶和数据异构。

## 3.1 消息队列双写模式

一般我们会在应用系统中采用双写模式，同时写DB和MQ，然后异构系统可以订阅MQ进行业务处理（如下图）。因为在双写模式下没有事务保证，所以会出现数据不一致的情况，如果对一致性要求没有那么严格，则这种模式是没有问题的，而且在实际应用中这种模式也非常多。

![](https://zhishan-zh.github.io/media/queue_20200508174443.png)

如下代码是双写示例，事务成功后发MQ。

```java
public OrderDTO create(final OrderDTO order) throws OrderException{
    OrderDTO createdOrderDTO = executeInShardingTrans((status) -> {
        //插入订单到DB
        OrderDTO insertOrderDTO = convert(orderService.insert(order));
        return insertOrderDTO;
    }, order);
    //发MQ
    orderMqProducer.publish(OrderMqType.CREATED, null, insertOrderDTO);
    //写缓存
    orderCache.put(createdOrderDTO);
    return createdOrderDTO;
}
```

## 3.2 双写模式存在的问题

如果在事务中发MQ，会存在事务回滚，但是MQ发送成功了，则需要消息消费者幂等处理。

- 如果事务提交慢，但是MQ已经发出去了，则此时根据MQ信息再去获取数据库数据可能不是最新的。
- 如果MQ发送慢，则会导致事务无法快速提交，造成数据库堵塞。
- 同样不要在事务中掺杂RPC调用，RPC服务不稳定，同样会引起数据阻塞。

## 3.3 把消息写入本地数据库，后台定时任务发送消息

![](https://zhishan-zh.github.io/media/queue_20200508180659.png)

1. 把消息写入本地数据库的消息表，与订单操作放在一个事务里面。
2. 一个定时执行的后台程序，从消息表中获取发送状态为“未发送”的消息发送给消息队列，消息状态改为“已发送”。
3. 积分系统负责保证幂等性。

## 3.4 使用订阅数据库日志机制

也可以采用订阅数据库日志机制来实现数据库变更捕获，这样生产系统只需要单写DB，然后通过如Canal订阅数据binlog实现数据数据变更捕获，然后业务端订阅Cannal进行业务处理。这种方式可以保证一致性。

![image-20200508183628556](https://zhishan-zh.github.io/media/image-20200508183628556.png)

# 4 请求队列

请求队列是指类似在Web环境下对用户请求排队，从而进行一些特殊控制：

- 流量控制：服务器处理能力有限，在接近服务器瓶颈时需要考虑限流，最简单的限流是丢弃处理不了的请求，此时可以使用队列进行流量控制；
- 请求分级：一些重要的请求可以优先处理（发展到一定程度应将功能物理分离）
- 请求隔离：请求按照功能划分到不同的队列，从而使得不同的队列出现问题后相互不影响；

如下图所示，这里使用请求队列来实现漏斗模式，对请求进行排队、过滤、限流，经过这些步骤后，流入业务系统的流量就非常小了，这样业务系统就不会被突发的大量请求搞垮。队列限流可以通过队列大小（如果队列满了，就抛弃新的请求）和排队超时（队列里的请求很长时间没被处理）实现，如果失败了，则返回让客户端重新排队或者重试。使用这种机制可以很好地保护系统不会收到突发流量的冲击。这种机制一般用于前端入口。

![image-20200508190107274](https://zhishan-zh.github.io/media/image-20200508190107274.png)

# 5 数据总线队列

一般消息队列中的消息都是业务维度的简单数据，如业务键或业务状态。在商品信息变更场景中，当SKU信息变更了，只下发一个SKU ID，订阅者需要再查一遍商品系统来获取最新的变更数据，进行如商品信息缓存同步。所以使用现有的消息队列方式很难只进行变更部分的推送并保存数据的有序性。而此种场景比较适合使用数据总线队列实现。例如数据库变更后需要同步数据到缓存，或者需要将一个机房的数据同步到另一个机房，只是数据维度的同步，此时应该使用数据总线队列，如阿里的Canal、LinkedIn的databus。使用数据总线队列的好处是，可以保证数据的有序性。阿里的Otter是基于Canal的一款分布式数据库同步系统，如果想实时进行多机房、多数据库数据增量同步，则可以使用Otter。如果需要圈梁离线数据同步，则可以使用kettle。

可以通过otter订阅某个DB的某些表，然后同步到另一个数据库中。如果系统中存在一些基础数据，则可以使用这种方式进行同步（如下图）。

![image-20200508191506098](https://zhishan-zh.github.io/media/image-20200508191506098.png)

# 6 混合队列

![image-20200508193017004](https://zhishan-zh.github.io/media/image-20200508193017004.png)

此处MQ是使用京东自主研发的JMQ，消息是可靠持久化存储的。应用会按照不同的维度发布消息到JMQ。下游应用接受到该消息后会将其放入Redis中，使用Redis List来存储这些任务。应用将Redis消息消费处理后，会按照不同的维度聚合商品消息，然后再次发送出去。

使用Redis队列的主要原因是想提升消息堆积能力和并发处理能力。另外，在使用Redis构建消息队列时，需要考虑因网络抖动造成的消息丢失问题，因为Redis是没有事务回滚的，或者说没有确认机制的。我们使用如下方式防止消息丢失。

```java
try{
    id = queueRedis.opsForList().rightPopAndLeftPush(queueName, processingQueueName);
} catch(Exception e) {
    //发生了网络异常，需要把processing中的id再放回到waiting queue中
    String msg = queueName + " to " + processingQueueName +　" rpoplpush error";
    LOG.error(msg, e);
    //报警代码
}
```

而对于失败我们会进行三次重试，重试失败后放入失败队列，而失败队列是具有放重功能的（从本地队列和失败队列排重），这里使用Redis Lua脚本实现。

```java
static EventQueueScript ADD_TO_FAIL_QUEUE_REDIS_SCRIPT = EventQueueScript("redis.call('lrem'， KEYS[1], 1, ARGV[1]) redis.call('lrem', KEYS[2], 1, ARGV[1]) return redis.call('lpush', KEYS[2], ARGV[1])");
```

Redis的作者Antirez开发的内存分布式消息队列Disque，是未来更好的内存消息队列选择。

# 7 优先级队列

在实际开发时肯定有些任务是紧急的，此时应该优先处理紧急任务。所以请考虑队列进行分级。

# 8 副本队列

在进行一些系统重构或者上新的功能时，如果没有足够的信息保证业务逻辑正确，则可以考虑存储一份队列的副本（比如1小时、1天的消息），从而当业务出现问题时，可以对这些消息进行回放。

# 9 镜像队列

每个队列不可能无限制被订阅消费，会有一个订阅量极限。当达到极限时，请考虑使用镜像队列方式解决该问题。

# 10 队列并发数

不同队列实现，队列服务器端并发连接数并发连接数是不一样的。一定不是增大队列并发连接数消费能力也随之增加，也不会因为增加了消费服务器消费，并发能力也随之增加，需要根据实际情况来设置合理的并发连接数。

# 11 推送拉取

消息体内容不是越安全越好，需要根据具体业务设计消息体。如有些系统依赖商品变更消息（只有一个SKU），有些系统依赖商品状态消息（SKU、状态），有些系统依赖商品属性变更消息（SKU、变更的属性）等。如果让所有的系统都消费商品变更消息，那么这些系统都会调用商品查询服务，拉取最新商品信息，然后进行处理。因此，要根据实际情况来决定是使用推送方式（将系统需要的所有信息推送过去）还是使用拉取方式（只推送ID，然后再查一遍）。

