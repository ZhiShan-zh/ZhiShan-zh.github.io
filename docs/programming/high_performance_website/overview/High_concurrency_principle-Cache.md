# 高并发原则——缓存

# 1 缓存的分类


缓存对于读服务来说可谓是流量的大救星，可总结为下表：

|       **流量节点** | 缓存技术                                                     |
| -----------------: | ------------------------------------------------------------ |
|         **客户端** | 使用浏览器缓存<br/>客户端应用缓存                            |
|     **客户端网络** | 代理服务器开启缓存                                           |
|         **广域网** | 使用代理服务器（含CDN）<br/>使用镜像服务器<br/>使用P2P技术   |
| **源站及源站网络** | 使用接入层提供的缓存机制<br/>使用应用层提供的缓存机制<br/>使用分布式缓存<br/>静态化、伪静态化<br/>使用服务器操作系统提供的缓存机制 |



## 1.1 浏览器端缓存


设置请求的过期时间，如对响应头Expires、Cache-control进行控制。这种机制适用于对实时性不太敏感的数据，如商品详情页框架、商家评分、评价、广告词等；但对于价格、库存等实时性要求比较高的数据，就不能做浏览器端缓存。


## 1.2 APP客户端缓存


在大促时为了防止瞬间流量冲击，一般在大促之前把APP需要访问的一些素材（如js/css/image等）提前下发到客户端进行缓存，这样在大促时就不用去拉取这些素材了。还有如首屏数据也可以缓存起来，在网络异常情况下还是有托底数据给用户展示；还有如APP地图一般也会做地图的离线缓存。


## 1.3 CDN缓存

有些页面、活动页、图片等服务可以考虑将页面、活动页、图片推送到离用户最近的CDN节点，让用户能在离他最近的节点找到想要的数据。

一般有两种机制：**推送机制**（当内容变更后主动推送到CDN边缘节点）和**拉取机制**（先访问边缘节点，当没有内容时，回溯到源服务器拿到内容并缓存到节点上），两种方式各有利弊。使用CDN时要考虑URL的设计，比如URL中不能有随机数，否则每次都穿透CDN回溯到源服务器，相当于CDN没有任何效果。对于爬虫，可以返回过期数据而选择不回溯。


## 1.4 接入层缓存


对于没有CDN缓存的应用来说，可以考虑使用如Nginx搭建一层接入层，该接入层可以考虑使用如下机制实现。


- **URL重写**：将URL按照指定的顺序或者格式重写，去除随机数。
- **一致性哈希**：按照指定的参数（如分类/商品编号）做一致性Hash，从而保证相同数据落在一台服务器上。
- **proxy_cache**：使用内存级/SSD级代理缓存来缓存内容。
- **proxy_cache_lock**：使用lock机制，将多个回源合并为一个，以减少回源量，并设置相应的lock超时时间。
- **shared_dict**：如果架构使用了nginx+lua实现，则可以考虑使用lua shared_dict进行cache，最大的好处就是reload缓存不会丢失。

此处要注意，对于托底（或兜底，指降级后显示的）数据或异常数据，不应该让其缓存，否则用户会在很长一段时间里看到这些数据。


## 1.5 应用层缓存


我们使用Tomcat时，可以使用堆内缓存/堆外缓存，堆内缓存的最大问题就是重启时内存中的缓存会丢失，此时流量风暴来临，则有可能冲垮应用；还可考虑使用local redis cache来代替堆外缓存；或在接入层使用shared_dict来将缓存前置，以减少风暴。


local redis cache，通过在应用所在服务器上部署一组Redis，应用直接读本机Redis获取数据，多机之间使用主从机制同步数据。这种方式没有网络消耗，性能时最优的。


### 1.5.1 Cache Aside策略


更新数据时不更新缓存，删除缓存中的数据。


读取数据时，如果缓存中没有数据，从数据库中读取，更新到缓存中。


### 1.5.2 Read/Write Through策略

**核心原则**：用户只与缓存打交道，由缓存和数据库通信，数据库的写入或者读取数据都是有缓存组件完成的。


注意，这里有一个关键角色，就是这个“缓存组件”，感觉优点像仓库管理员。


## 1.6 分布式缓存


有一种机制是要废弃分布式缓存，改为应用local redis cache情况下，如果数据量不大，这种架构是最优的。但是如果数据量太大，单服务器存储不了，那么可以使用分片机制将流量分散到多台，或者直接用分布式缓存实现。常见的分片规则就是一致性哈希了。


![image-20200418102733946.png](https://zhishan-zh.github.io/media/1587183355280-792ed5d6-b580-4214-bb74-1296662ffc1d.png)


如上图所示就是我们一个应用的架构。


- 首先接入层（nginx+liua）读取本地proxy cache / local cache。
- 如果不命中，则接入层会读取分布式Redis集群。
- 如果还不命中，则会会源到Tomcat，然后读取Tomcat应用堆内cache。
- 如果缓存都没命中，则调用依赖业务来获取数据，然后异步化写到Redis集群。



因为我们使用了nginx+lua，第二、三步时可使用lua-resty-lock非阻塞锁来减少峰值的会源量：如果你的服务是用户维度的，那么这种非阻塞锁大部分情况下不会有太大作用（要看具体场景）。


# 2 缓存服务器的经典问题


## 2.1 雪崩


缓存雪崩：缓存中大量数据同时失效（缓存过期或缓存服务器宕机）导致数据库压力过大。


解决方案：


- 为有效期增加随机值。
- 使用高可用分布式缓存
- 热点数据永远不过期。
- 在缓存失效后，通过加锁或者队列来控制读数据库的线程数量。

## 2.2 穿透


缓存中没有，需要访问数据库，这就是缓存被穿透了。


缓存穿透后就需要访问数据库，如果访问量大的话就可能压垮数据库。


### 2.2.1 解决方案——缓存空值


正常请求不存在的数据，可能其他请求也会读取这个数据，为防止多次无效访问数据库，我们可以把这个空值也缓存起来，用户下次再请求时，就直接返回空。


### 2.2.2 解决方案——布隆过滤器


大量恶意请求不存在的数据，即使缓存空值也无效，大量请求读取数据库，需要使用布隆过滤器帮助我们在不查询数据库的情况下就知道此ID是否存在，把恶意请求直接过滤掉。


#### 2.2.2.1 布隆过滤器（Bloom Filter）原理


##### 2.2.2.1.1 概述

1970年布隆提出了一种过滤器的算法，用来判断一个元素是否在一个集合中。


##### 2.2.2.1.2 为什么要用布隆过滤器


如果想要判断一个元素是不是在一个集合里，一般想到的是将所有元素保存起来，然后通过比较确定。链表，树等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大，检索速度也越来越慢(O(n),O(logn))。不过世界上还有一种叫作散列表（又叫哈希表，Hash table）的数据结构。它可以通过一个Hash函数将一个元素映射成一个位阵列（Bit array）中的一个点。这样一来，我们只要看看这个点是不是1就可以知道集合中有没有它了。这就是布隆过滤器的基本思想。


##### 2.2.2.1.3 算法


直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。

和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。


具体算法：


1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数；
2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0；
3. 某个key加入集合时，用k个hash函数计算出k个散列值，并用k个散列值对数组长度取模计算出，k个位置，并把数组中对应的比特位置为1；
4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。

##### 2.2.2.1.4 优缺点


优点：不需要存储key，节省空间。


缺点：


1. 由于hash冲突，存在误判。这个问题可以使用多个（一般是3个）hash函数一起计算，提高精度；
2. 算法判断key在集合中时，有一定的概率key其实不在集合中；
3. 无法删除。可以使用int数组替代比特数组，使用hash函数计算出数组位置的时候，不是把位置的值简单变为1，而是加1，删除的时候对应位置减1。但是这种解决方案增加了不小的成本。

#### 2.2.2.2 如何使用布隆过滤器


1. 写入数据时，更新布隆过滤器；
2. 查询数据时，先查询布隆过滤器是否存在，如果不存在，直接返回空，如果存在，再去查询数据库。
