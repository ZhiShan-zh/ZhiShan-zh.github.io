# Jedis中的管道Pipeline

# 1 简介

## 1.1 概述

Redis采用的是CS架构，客户端与服务器端通过TCP协议进行连接通信，因此无论是发出请求还是接收响应，都必须经过网络传输。在TCP连接过程中，客户端和服务器端是通过阻塞式的一问一答方式进行通信的，即客户端必须接收到服务端完整的响应，才能进行后续请求。

管道（Pipeline）方式意味着客户端可以在一次请求中发送多个命令。

当我们会在短时间内发送大量互不依赖的命令（后执行的命令不需要使用前面返回的结果）。由于网络传输不可避免的会造成一定的延迟，特别是在跨机器远程访问Redis的时候，如果使用常规的方式，一条命令对应一次请求和响应的话，大量命令累计的延迟会显得很高。Redis的设计者考虑到这一点，在底层的通信协议上，通过支持"管道（Pipeline）"来解决这一问题。

管道（Pipeline）相当于批处理脚本 , 相当于命令集。

## 1.2 管道（Pipeline）批处理的命令是不是越多越好？

由于redis的管道要求服务器一次性的将请求返回，因此redis服务端只能将靠前命令处理的结果暂时缓存起来。如果管道一次响应的数据量过多(大规模查询之类的)，可能会对redis服务器的内存造成较大的压力。因此，管道批量处理的命令数量并不是越多越好，需要结合实际需求，合理的决定一次管道批处理命令的数量。

## 1.3 管道（Pipeline）命令缓冲区问题

Redis的管道（Pipeline）在客户端通常会设置一个命令缓冲区来存储即将被批量发送的命令，当缓冲区被填满时，才会一次性的将缓冲区的命令发送。

这里需要注意的一点是：当业务上的同一批命令使用管道进行请求时，如果最后剩余的命令无法填满缓冲区，如果不使用相应的flush操作，这些命令将不会被发送出去，而是保留在命令缓冲区等待新的命令来填满缓冲区。

## 1.4 管道（Pipeline）是非原子性操作

- Pipeline操作是非原子性的，而mset是原子性的。mset批量操作要么都成功要么都失败，而Pipeline则不能保证。
  - 解决方案：我们在进行批量操作时应尽可能的把批量操作拆分成小粒度的Pipeline。
- mset只是set一个命令的批量操作，而Pipeline则可以批量发送多个命令，这里就存在事务的问题。
  - 解决方案：要保证多个命令的事务，就需要使用redis提供的事务相关的命令，但redis中的事务是“假事务”，因为它仍然不能保证原子性。

## 1.5 分布式集群环境下使用管道（Pipeline）

如果Redis是集群，则初始化使用的是JedisCluster，但是JedisCluster是不提供获取Pipeline对象的 pipelined()方法的。

但是我们可以根据要插入的key知道这个key所对应的槽的号码，再通过这个槽的号码从集群中找到对应jedis。

如果发生了resharding（重新切分。水平扩展集群，而水平扩展集群即新增master节点，Redis Cluster就需要重新划分slot）/rebalance（分配权重），会导致slot变动，则打包好的管道中的部分命令可能会收到MOVED或ASK错误，需要在代码中处理。一般而言，遇到MOVED需要触发一次映射刷新，遇到ASK则需要一次ASKING操作。

# 2 入门案例

```java
@Test
public void jedisPipeline(){
	Jedis jedis=new Jedis("127.0.0.1",6379);
	//开启redis管道
	Pipeline pipeline=jedis.pipelined();
	for (int i = 0; i < 1000; i++) {
        //在管道中添加数据
		pipeline.set("Pipeline" + i, i + "");
	}
	pipeline.sync();//管道提交数据
}
```

