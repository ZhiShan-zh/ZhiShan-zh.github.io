# MySQL 索引

# 1 MySQL索引类型

## 1.1 普通索引

key ，唯一的作用就是加快查询的速度

## 1.2 主键索引

primary key 。字段具备唯一性 一张数据表中只有一个

## 1.3 唯一索引

unique key 。

## 1.4 联合索引

key(a,b,c)。

## 1.5 外键索引

在我现在的认识中，就是用来维护数据表之间的相关性的，并且会导致数据的写入等操作的速度过慢，所以。。好像没啥用（对于较大的项目）

## 1.6 全文索引

### 1.6.1 模糊匹配和全文索引

#### 1.6.1.1 用 like + % 就可以实现模糊匹配了，为什么还要全文索引？

- like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。
- 全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。
    - 全文索引是倒排索引，先进行分词然后进行查询，因为分词的原因可能导致精度问题。

#### 1.6.1.2 简介

- MySQL中的全文索引是FULLTEXT类型的索引。
- 全文索引只能用于InnoDB或MyISAM表，只能为CHAR、VARCHAR、TEXT列创建。
    - FULLTEXT在mysql5.6以前的InnoDB表不支持。
- 在MySQL 5.7.6中，MySQL提供了支持中文、日文和韩文（CJK）的内置全文ngram解析器，以及用于日文的可安装MeCab全文解析器插件
    - 在MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引，需要利用分词器把中文段落预处理拆分成单词，然后存入数据库。
    - 从MySQL 5.7.6开始，MySQL内置了ngram全文解析器，用来支持中文、日文、韩文分词。
    - 在使用中文检索分词插件ngram之前，先得在MySQL配置文件里面设置他的分词大小（默认是2）
- 当创建表时，可以在CREATE TABLE语句中给出FULLTEXT索引定义，或者稍后使用ALTER TABLE或CREATE INDEX添加该定义。
- 对于大型数据集，将数据加载到没有FULLTEXT索引的表中然后创建索引要比将数据加载到具有现有FULLTEXT索引的表中快得多
- 如果要导入大数据集，使用先导入数据再在表上创建全文索引的方式要比先在表上创建全文索引再导入数据的方式快很多，所以全文索引是很影响TPS的。

使用：WHERE MATCH(column) AGAINST('search_content')

- MATCH()函数使用的字段名只能是同一个表的字段，因为全文索引不能够跨多个表进行检索。

#### 1.6.1.3 常用的全文检索模式

- 自然语言模式(NATURAL LANGUAGE MODE) ，
    自然语言模式是MySQL 默认的全文检索模式。自然语言模式不能使用操作符，不能指定关键词必须出现或者必须不能出现等复杂查询。
    - 使用：`WHERE MATCH(column) AGAINST('search_content'  IN NATURAL LANGUAGE MODE)`
    - 不指定模式，默认使用自然语言模式
- BOOLEAN模式(BOOLEAN MODE)
    BOOLEAN模式可以使用操作符，可以支持指定关键词必须出现或者必须不能出现或者关键词的权重高还是低等复杂查询。

# 2 聚集索引和辅助索引以及覆盖索引

- 聚集索引（主键索引）：
    - 聚集索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的即为整张表的记录数据。
    - 聚集索引的叶子节点称为数据页，聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。
- 辅助索引（二级索引）：
    - 非主键索引，也是B+树，叶子节点=键值+书签。Innodb存储引擎的书签就是相应行数据的主键索引值。

- 覆盖索引：
    - 覆盖索引是select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。
        - 索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。
        - 是非聚集复合索引的一种形式，它包括在查询里的Select、Join和Where子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段，也即，索引包含了查询正在查找的数据）。

# 3 对大字段进行部分内容索引

## 3.1 如果是完整内容检索，可以建立hash索引

1. 新建一个列为查询字段的hash值。
2. 查询的时候，先求要查询字段的hash值，然后把hash字段放在where靠前位置，查询字段并列查询放在其后。

## 3.2 前缀索引

- 创建前缀索引的语句：
    - `ALTER TABLE table_name ADD KEY (column_name(5));`（对数据库table_name的字段column_name前5个字符建立索引）

- 要考虑选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）,最后还要考虑数据分布。
    - 计算完整列的选择性：`SELECT COUNT(DISTINCT column_value)/COUNT(*)  FROM table_name;`
    - 计算不同前缀长度的选择性：
        - 前缀长度为3时的选择性：`SELECT COUNT(DISTINCT LEFT(column_value,3))/COUNT(*)  FROM table_name;*`
        - 前缀长度为5时的选择性：`SELECT COUNT(DISTINCT LEFT(column_value,5))/COUNT(*)  FROM table_name;*`
- 使用前缀索引：使用前缀索引和其他索引类型没有区别。
    - `SELECT * FROM table_name WHERE column_name = ‘column_value’`

# 4 %%模糊匹配走索引的原理

参见：https://blog.csdn.net/Howinfun/article/details/104757012

# 5 MySQL索引类型和长度的限制

MySQL中对于数据类型的索引限制：

- 在MySQL中BLOB和TEXT如果要建立索引（非全文索引），但必须给出前缀索引的长度 。

MySQL对索引字段长度有限制：

- innodb引擎的每个索引列长度限制为767字节（bytes），所有组成索引列的长度和不能大于3072字节；
- myisam引擎的每个索引列长度限制为1000字节，所有组成索引列的长度和不能大于1000字节；
- varchar的最大长度是指字符长度，若数据库字符集为utf-8，则一个字符占3个bytes。因此在utf-8字符集下，innodb引擎创建的单列索引长度不能超过255（767/3=255）个字符；
- GBK编码：00-7F属于ASCII编码，8140-FEFE才属于GBK编码，GBK编码支持与ASCII编码混编。
    - 字符串中，英文与数字字符属于ASCII编码，故占用一个字节，中文字符属于GBK编码，故占用两个字节.
    - 实际是GBK字符集里也有英文与数字字符，但属于全角字符，占用两具字节。

