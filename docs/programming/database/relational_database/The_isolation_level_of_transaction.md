# 事务的隔离级别

# 1 事务的四个特征（ACID）

- **原⼦性（Atomicity）**：

  - 操作要么全部成功，否则回滚，什么也不做（“要么不做，要么全做！ ”）
- **⼀致性（Consistency)**：

  - 事务操作之后,数据库所处的状态和业务规则是⼀致的；⽐如a,b账户相互转账之后，总⾦额不变！
  - 如果数据库系统运⾏中发⽣故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有⼀部分已写⼊物理数据库，这时数据库就处于⼀种不正确的状态，或者说是不⼀致的状态。
- **隔离性（Isolation）**：

  - 事务的隔离级别有4级，⼀个事务的执⾏不能有其他事务的⼲扰，事务的内部操作和使⽤数据对其他的并发事务是隔离的，互不⼲扰。
- **持久性（Durability）**：

  - 事务⼀旦提交后，他对数据的改变应该永久性的，不能回滚。接下来其他的操作或者故障不会对已经提交了的事务产⽣影响。

# 2 事务隔离级别

隔离级别决定了⼀个session中的事务可能对另⼀个session中的事务的影响。 ANSI标准定义了4个隔离级别， MySQL的InnoDB和Oracle都⽀持，分别是

## 2.1 READ UNCOMMITTED(读取未提交)

**事务管理**：允许一个写线程和多个读线程同时操作此条数据。

**实现技术**：

- **排他写锁**：（行级锁）

  - 用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时同一资源进行多重更新。
  - 如果事务T对数据A加上排他写锁后，则其他事务不能再对A加任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

**存在的问题**：

- **脏读**：线程B读取到了线程A未提交的数据。

## 2.2 READ COMMITTED（读取已经提交）

**事务管理**：

- 读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。
- 正在读取的数据只获得了读取锁，读完之后就解锁，不管当前事务有没有结束，这样就容许其他事务修改本事务正在读取的数据。

**实现技术**：

- _瞬间共享读锁_：（行级锁）

  - _共享锁（S锁）_：共享 (S) 用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

    - 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
    - 加了排他锁后也就无法加上共享锁，这就保障了一个写事务未提交之前无法被需要加共享锁的事务访问。
  - 瞬间的意思是锁针对的单条语句，不是整个事务。
- _排他写锁_：（行级锁）

**存在的问题**：

- _不可重复读_：事务A事先读取了数据，但未提交事务，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。

## 2.3 REPEATABLE READ（可重复读）

**事务管理**：读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

**实现技术**：

- 共享读锁：（行级锁）
- 排他写锁：（行级锁）

**存在的问题**：

- _幻读_：

  - 只能保证正在被本事务操作的数据不被其他事务修改，却⽆法保证有其他事务提交新的数据。
  - ⽐如：事务A在查询表T1（特别是统计性的事务），但并没提交事务，事务B仍然可以提交新数据到表T1并提交事务，然后事务A又查询表T1，这样会导致事务A两次统计的结果不⼀致，就像发⽣幻觉⼀样。

## 2.4 SERIALIZABLE（序列化）

**事务管理**：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。

**实现技术**：仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

**存在的问题**：这种事务隔离级别效率低下，比较耗数据库性能，一般不用。

# 3 常见数据库的隔离级别

## 3.1 Oracle

- serializable
- read committed

  - 默认
- read only

  - Oracle⾃⼰独有的事务隔离级别

## 3.2 MySQL（InnoDB）

四种全部支持，默认是REPEATABLE READ
