# 树和二叉树自测

- 1 概述
  - [1.1 树在计算机中的应用有那些？](# 1.1 树在计算机中的应用有那些？)
- 2 树的定义和基本术语
  - [2.1 树的定义？树的描述？什么是子树？](# 2.1 树的定义？树的描述？什么是子树？)
  - [2.2 树的抽象数据类型的定义](# 2.2 树的抽象数据类型的定义)
  - [3.3 二叉树的性质](# 3.3 二叉树的性质)
  - [3.4 二叉树的存储结构有那些？各有什么特点？](# 3.4 二叉树的存储结构有那些？各有什么特点？)
- 4 遍历二叉树和线索二叉树
  - [4.1 简述遍历二叉树的三种遍历方案？遍历二叉树的实质是什么？](# 4.1 简述遍历二叉树的三种遍历方案？遍历二叉树的实质是什么？)
  - [4.2 什么叫做线索链表、线索、线索二叉树、线索化？](# 4.2 什么叫做线索链表、线索、线索二叉树、线索化？)
- 4 树和森林
  - [4.1 树的存储结构有那些？其存储结构是怎么的？](# 4.1 树的存储结构有那些？其存储结构是怎么的？)
  - [4.2 树和二叉树怎么相互转换？](# 4.2 树和二叉树怎么相互转换？)
- 5 赫夫曼树
  - [5.1 什么是赫夫曼树？](# 5.1 什么是赫夫曼树？)
  - [5.2 如何构造赫夫曼树？也就是简述赫夫曼算法？](# 5.2 如何构造赫夫曼树？也就是简述赫夫曼算法？)

# 1 概述

## 1.1 树在计算机中的应用有那些？

- 编译程序中，使用树表示源程序的语法结构。
- 数据库系统中，树形结构是重要的信息组织形式。

# 2 树的定义和基本术语

## 2.1 树的定义？树的描述？什么是子树？

定义：树（Tree）是n（$n \ge 0$）个结点的有限集。

描述：

- 一个根节点
- 其余结点为m个互不相交的有限集。
  - 每个集合又是一棵树，称为根的子树（SubTree）

## 2.2 树的抽象数据类型的定义

- 初始化——删除
- 创建——清空
- 判空
- 求树的深度
- 求根节点——求双亲——求左孩子——求右兄弟
- 插入孩子结点（哪个树，哪个结点的孩子结点？哪个孩子结点之后？插入的孩子结点？）——删除孩子结点（哪个树？哪个结点的孩子结点？第几个孩子结点？）
- 求结点的值——给结点赋值

# 3 二叉树

## 3.1 二叉树的特点？

每个结点至多只有两颗子树，有序

## 3.2 二叉树的抽象数据结构？

相比于树的抽象数据结构，因为子树的数目最多为二，所以新增了：

- 求右子树——求右兄弟
- 遍历树：先序遍历、中序遍历、后续遍历、层序遍历

## 3.3 二叉树的性质

以3个结点的完全二叉树为例推导：

- 第i层上的结点个数：至多有$2^{i-1}$
- 深度为k的二叉树结点个数：$2^k - 1$
- 终端结点个数$n_0$和度为2的结点个数$n_2$的关系：$n_0 = n_2 + 1$
- n个结点的完全二叉树的深度：$\lfloor log_2{n} \rfloor + 1$
- 完全二叉树，第i个结点：
  - i=1：为根节点，无双亲
  - $i \gt 1$：双亲为$\lfloor i/2 \rfloor$
  - 若$2i \gt n$：无左孩子
    - 否则，左孩子为$2i$
  - 若$2i+1 \gt n$：无右孩子
    - 否则，右孩子为$2i + 1$

## 3.4 二叉树的存储结构有那些？各有什么特点？

- 顺序存储结构：
  - 数组存储
  - 比较适用于完全二叉树：非完全二叉树，需要用空占位，以保证能还原二叉树
- 链式存储结构：
  - 至少包含3个域：数据域和左、右孩子指针域
  - 为了便于查找双亲，可以增加一个指向其双亲结点的指针域。

# 4 遍历二叉树和线索二叉树

## 4.1 简述遍历二叉树的三种遍历方案？遍历二叉树的实质是什么？

- 先序遍历：
  - 先访问根结点
  - 先序遍历左子树
  - 先序遍历右子树
- 中序遍历：
  - 中序遍历左子树
  - 访问根节点
  - 中序遍历右子树
- 后序遍历：
  - 后序遍历左子树
  - 后序遍历右子树
  - 访问根节点

**遍历二叉树的实质是**：遍历二叉树是以一定规则将二叉树中结点排列成一个线性序列，这实质上是对一个非线性结构进行线性化操作，使每个结点（除了第一个和最后一个外）在这个线性序列中有且仅有一个直接前驱和一个直接后继。

## 4.2 什么叫做线索链表、线索、线索二叉树、线索化？

**线索链表**：在二叉树链式存储结构中增加存储线索（指向结点直接前驱和直接后继的指针）信息的存储结构为线索链表。

加上线索的二叉树叫做线索二叉树。

对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**。

# 4 树和森林

## 4.1 树的存储结构有那些？其存储结构是怎么的？

- **双亲表示法**：
  - 树结构：
    - 使用数组方式存储结点
    - 根的位置
    - 结点数
  - 结点结构：结点数据、双亲位置
- **孩子表示法**：
  - 数结构：
    - 使用数组方式存储结点
    - 根的位置
    - 结点数
  - 结点结构：
    - 第一种格式：固定孩子链表长度，造成很多空链域，空间较浪费
      - 结点数据
      - 孩子链表头指针
    - 第二种格式：结点的多重链表是不同构的，节约了空间，但操作不便
      - 结点数据
      - 孩子链表头指针
      - 度
  - 孩子结点：
    - 孩子结点的在数组中的位置
    - 下一个孩子结点指针
- **孩子兄弟表示法**：又称二叉树表示法、二叉链表表示法
  - 结点结构：
    - 结点数据
    - 第一个孩子结点指针
    - 下一个孩子结点指针

## 4.2 树和二叉树怎么相互转换？

森林$F=\{T_1,T_2,...,T_m\}$和二叉树$B=\{root,LB,RB\}$：

- $root = Root(T_1)$
- $LB = F_1, F_1 = \{T_{11}, T_{12},...,T_{1n}\}$
  - $F_1$为$T_1$的子树森林。
- $RB = F^`, F^` = \{T_2,T_3,...,T_m\}$#

# 5 赫夫曼树

## 5.1 什么是赫夫曼树？

**路径长度**：从树的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称为路径长度。

**树的路径长度**：从树根到每一个结点的路径长度之和。

**结点的带权路径长度**：从**该结点到树根之间**的路径长度和结点上权的乘积。

**树的带权路径长度**：所有叶子结点的带权路径长度之和，记为WPL。
$$
WPL = \sum_{k=1}^n{w_kl_k}
$$
**最优二叉树（赫夫曼树）**：树的带权路径长度最小的二叉树。

## 5.2 如何构造赫夫曼树？也就是简述赫夫曼算法？

1. 根据给定的n个权值$\{w_1, w_2,...,w_n\}$构成n棵二叉树的集合$F=\{T_1, T_2, ..., T_n\}$，其中每棵二叉树$T_i$中只有一个带权为$w_i$的根结点，其左右子树为空。
2. 在F中选取两颗根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为左、右子树上根节点的权值之和。
3. 在F中删除这两棵树，同时将新得到的二叉树加入到F中。
4. 重复2和3，直到F中只含一棵树为止。这棵树便为赫夫曼树。

## 5.3 赫夫曼树和最优查找树的区别？

