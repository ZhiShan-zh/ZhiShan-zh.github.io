# 软件架构设计

在本部分，**软件“体系结构”和“架构”具有相同的含义**。

# 1 软件架构概念

## 1.1 软件架构的定义

软件架构是具有一定形式的结构化元素，即构件的集合，包括处理构件、数据构建和连接构件。

- 处理构件：负责对数据进行加工；
- 数据构件：被加工的信息；
- 连接构件：把架构的不同部分连接起来。 



软件架构包括一个或一组软件构件、软件构件的外部的可见特性及其相互关系。

- 软件外部的可见特性：是指软件构件提供的服务、性能、特性、错误处理、共享资源使用等。 
- 在架构设计的环境中，软件构件可以简单到程序模块或者面向对象的类，也可以扩展到包含数据库和能够完成客户与服务器网络配置的“中间件”。



软件架构处理算法与数据结构之上关于整体系统结构设计和描述方面的一些问题，如全局组织和全局控制结构、关于通信、同步与数据存取的协议，设计构建功能定义，物理分布和合成，设计方案的选择、评估与实现等。

架构并非可运行软件。确切地说，它是一种表达，使软件工程师能够：

- 分析设计在满足狗顶需求方面的有效性。
- 在设计变更相对容易的阶段，考虑架构可能的选择方案。
- 降低与软件构造相关的风险。

## 1.2 软件架构设计与生命周期



# 2 基于架构的软件开发方法

# 3 软件架构风格

软件架构设计的一个核心目标是重复的架构模式，即达到架构级的软件重用。

- 也就是说，在不同的软件系统中，使用同一架构。

## 3.1 软件架构风格概述

- 软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式（idiomatic paradigm）。
- 架构风格定义了一个系统家族，即一个架构定义一个词汇表和一组约束
  - 词汇表：包含构件和连接件。
  - 约束：定义构件和连接件的组合方式。
- 架构风格反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。
  - 按照这种方式理解，软件架构风格定义了用于描述系统的术语表和一组指导构件系统的规则。



**通用架构风格分类**：

- 数据流风格：批处理序列，管道/过滤器。
- 调用/返回风格：主程序/子程序，面向对象风格，层次结构。
- 独立构件风格：进程通信，事件系统。
- 虚拟机风格：解释器，基于规则的系统。
- 仓库风格：数据库系统，超文本系统，黑板系统。

## 3.2 经典软件架构风格

### 3.2.1 管道/过滤器

![](https://ZhiShan-zh.github.io/media/software_architecture_design_20210217130612.jpg)

在管道/过滤器风格中，**每个构件都有一组输入和输出**，构件读输入的数据流，经过内部处理，然后产生输出数据流。因此，这里的构件称为**过滤器**，这种风格的连接件就像数据流传输的**管道**，将一个过滤器的输出传到另一个过滤器的输入。此风格中特别重要的过滤器必须是独立的实体，它**不能与其他的过滤器共享数据**，而且**一个过滤器不知道它上游和下游的标识**。

> 一个典型的管道/过滤器架构的粒子是以UNIX shell编写的程序：UNIX既提供一种符号，以连接各组成部分（UNIX的进程），又提供某种进程运行机制以实现管道。
>
> 另一个著名的例子就是传统的编译器：传统的编译器一直被认为是一种管道系统，在该系统中，一个阶段（包括词法分析、语法分析、语义分析和代码生成）的输出是另一个阶段的输入。

风格的优点：

- 使得构件具有良好的隐蔽性和高内聚、低耦合的特点。
- 允许设计者将整个系统的I/O行为看成是多个过滤器行为的简单合成。
- 支持软件重用。只要提供适合在两个过滤器之间传递的数据，任何两个过滤器都可被连接起来。
- 系统维护简单，可扩展性好。新的过滤器可以添加到现有系统中来；旧的可以被改进的过滤器替换掉。
- 允许对一些属性，如吞吐量、死锁等进行分析。
- 支持并行执行。每个过滤器是作为一个单独的任务完成，因此可与其他任务并行执行。

风格缺点：

- 通常导致进程成为批处理的结构。这是因为虽然过滤器可增量式地处理数据，但它们是独立的，所以设计者必须将每个过滤器看成一个完整的从输入到输出的转换。
- 不适合处理交互的应用。当需要增量地显示改变时，这个问题尤为严重。
- 因为在出局传输上没有通用的标准，每个过滤器都增加了解析和合成数据的工作，这样就导致了系统性能下降，并增加了编写过滤器的复杂性。

### 3.1.2 面向对象风格

![](https://ZhiShan-zh.github.io/media/software_architecture_design_20210217132118.jpg)

面向对象风格建立在数据抽象和面向对象的基础上，数据的标识方法和它们的相应操作封装在一个抽象数据类型或对象中。这种风格的构件是对象，或者说是抽象数据类型的实例。

风格优点：

- 因为对象对其他对象隐藏它的表示，所以可以改变一个对象的表示，而不影响其他的对象。
- 设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。

风格缺点：

- 为了使一个对象和另一个雕像通过过程调用等进行交互，必须知道对象的标识。只要一个对象的标识改变了，就必须修改所有其他明确调用它的对象。
- 必须修改所有显示调用的其他对象，并消除由此带来的一些副作用。

### 3.1.3 事件驱动系统

基于事件驱动系统风格的思想是构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中的其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程，这样，一个事件的触发就导致了一个模块中的过程的调用。

从架构上说，这种风格的构件是一些模块，这些模块既可以是一些过程，又可以是一些事件的集合。过程可以用通用的方式调用，也可以在系统事件中注册一些过程，当发生这些事件时，过程被调用。

**主要特点**：事件的出发者并不知道那些构件会受到这些事件影响。由于不能假定构件的处理顺序，甚至不知道那些过程会被调用，因此，许多隐式调用的系统也包含显示调用作为构件交互的补充形式。

优点：

- 为软件重用提供了强大的支持。当需要将一个构件加入到现存系统中时，只需将它注册到系统的事件中。
- 为改进系统带来了方便。当用一个构件代替另一个构件时，不会影响到其他构件的接口。

缺点：

- 