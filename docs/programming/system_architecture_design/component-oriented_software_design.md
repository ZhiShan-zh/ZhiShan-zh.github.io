# 面向构件的软件设计

# 1 构件的概念

对象常被称为类的实例，对象和构建都通过类或接口向外界提供服务。对于对象和构件之间的交互，设计人员常用模式描述，用框架规范。而构件和框架又都常被称为是白盒的或黑盒的。

## 1.1 术语与概念

软件构件是一种组装单元，它具有规范的接口规约和显式达到语境依赖。软件构件可以被独立地部署并由第三方任意地组装。

### 1.1.1 构件

构件的特性：

- 独立部署单元
- 作为第三方的组装单元
- 没有（外部的）可见状态

这些特性有几重含义：

- 一个构件是独立可部署的，意味着它必须能跟它所在的环境及其他构件完全分离。因此，构件必须封装自己的全部内部特征。并且，构件作为一个部署单元，具有原子性，是不可拆分的。也就是说，第三方没有权利访问其所使用的任何构件的内部细节信息。
  - 在这样的约束下，如果第三方厂商能将一个构件和其他构件组装在一起，那么这个构件不但必须具备足够好的内聚性，还必须将自己的依赖条件和所提供的服务说明清楚。换句话说，构件必须封装它的实现，并且只通过良好定义的接口与外部环境进行交互。
- 一个构件不能有任何（外部的）可见状态——这要求构件不能与自己的拷贝有所区别。
  - 但对于不影响构件功能的某些属性。例如，用于计费的序列号，则没有这种限制。
  - 通过对属性的可见性进行限制，允许用户在不影响构件的可见行为的前提下，使用合法的技术手段对那些影响性能的状态进行特殊处理。
    - 特别是，构件可以将某些状态专门用于缓存（缓存具有这样的特性：当它被清空时除了可能会降低性能以外，没有其他后果）。
  - 构件在特定的系统中可以被装载和激活。但是，由于构件本质上没有状态，因此在同一操作系统进程中装在多个构件的拷贝时毫无意义的，而且它们之间是不可区分的。也就是说，给定一个进程（或者其他的语境），至多会存在一个特定构件的拷贝。因此谈论某个构件的可用拷贝的数量是没有任何意义的。

在目前许多系统中，构件被实现为大粒度的单元，系统中的构件只能有一个实例。例如，一个数据库服务器可以作为一个构件。如果这个服务器刚好只维护有了一个数据库，那么会很容易把该数据库误认为是实例，如公司里的员工工资管理服务器。该数据库服务器连同其中的数据库，可以被视为一个有可见状态的模块。根据上边的定义，该数据库并不是一个构件，但那个静态的数据库服务器程序却是一个构件——它只支持一个数据库“对象”实例。也就是说，在这个实例中，工资管理服务器程序是一个构件，而其中的工资数据只是实例（对象）。这种将不易变得“模型”和易变得“实例”分离得做法避免了大量得维护问题。如果允许构件永恒石可见状态得话，那么任何两个来自同一个构件的实例都不会拥有相同的属性。

### 1.1.2 对象

对象的特性：

- 一个实例单元，具有唯一的标志。
- 可能具有状态，此状态外部可见。
- 封装了自己的状态和行为。

由于对象是一个实例化的单元，所以不能被局部初始化。

由于对象有各自的状态，它必须有唯一的标志，以使它在整个生命周期内，无论状态如何改变，都能被唯一地识别。

当对象被实例化的时候，需要一个构造方案来描述其状态空间、初始状态和新生对象的行为。该方案在对象存在之前就已经存在。**显式存在的实例化方案**称为类。也有**隐式的实例化方案**，即通过克隆一个已存在的对象来实现，即原型对象。

无论使用类的形式，还是用原型对象的形式实例化一个车对象，这个新生的对象都必须被设置一个初始状态。创建与初始化控制对象的代码可以是一个静态的过程——如过它是对象所从属类的一部分，就被称为构造函数。如果这个对象是专门用来创建于初始化对象的，则简称为工厂。对象中专门硬塞了返回其他新创建的对象的方法常被称为工厂方法。

### 1.1.3 构件和对象

构件的行为显然可以通过对象来实现，因此构件通常包含了若干类或不可更改的原型对象。初次之外，构件还包括一系列对象，这些对象被用来获取默认的初始状态和其他的构建资源。

但构件并非一定要包含类元素，它甚至可以不包含类。实际上，构件可以拥有传统的过程体，甚至全局变量，它也可以通过函数语言，或者汇编语言，或者其他可用的方法实现自身的全部特性。

一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。另外，正如一个类元素可以通过继承关系等产生依赖一样，否见之间也可以存在相互依赖的关系——这种依赖很重要。一个类的父类并不一定与它的子类存在于一个构件中。如果一个类的父类存在于外部的其他构件中，那么这两个类之间的继承关系便是跨构件的，这种关系将会导致相关联的构件间的导入关系。规约的继承是保证正确性的一项很关键的技术，因为共同的规约是构件间达成共识的基础。

### 1.1.4 模块

构件与模块的概念其实非常类似。

随着Eiffel语言的面世，类被认为是更好的模块（Meyer，1998）。这似乎是正确的，因为我们最初的想法是每个模块实现一种抽象数据类型。毕竟，我们可以把一个类堪称是一个抽象数据类型的实现，只不过它多了继承和多态的特性而已。然而，模块常常被用于把多个诸如抽象数据类型、类等实体打包到一个单元中。并且，模块没有实例化的概念，而类却有。

在其后的程序设计语言中——比如Modula-3、Componet Pascal和C#——模块的概念（C#中的集合）与类的概念是区分对待的。在任何情况下，模块都可以包含多个类。在有些没有模块概念的语言（诸如Java语言）中，模块可以通过嵌套类来模拟实现。类之间的继承关系并不受模块界限的影响。

模块本身就可以作为一个最简单的构件。即使不包含任何类元素的模块也可以实现构件的功能。然而，一个成熟的复杂的构件却并不是简单地仅用模块就可以实现的。模块没有持久不变的资源，有的只是那些被硬编码到程序中的常量。资源可以参数化一个构件。通过替换这些资源，就可以重新配置该构件而无需更改构件代码。

在某些情况下，模块并不适合作为构件。构件没有外部可见的状态，但是模块却可以显式地用全局变量来使其状态可见。并且，通过直接导入其他模块的接口，模块之间可以存在静态的代码依赖。而对于构件来说，虽然也允许存在对构件外部代码的静态依赖关系，但却并不提倡。这种静态依赖关系应被限定用于那些合约元素，包括类型和常量。使用间接而非直接的接口表示模块的依赖关系，把对实现代码的依赖关系现定于对象的层次，就可以利用同一接口的不同实现来灵活地组装模块。

### 1.1.5 白盒抽象、黑盒抽象与重用

黑盒抽象与白盒抽象的区别主要在于接口“后面”的实现细节是否可见。在理想的黑盒抽象的情况下，客户对接口和规约之外的实现细节一无所知。而在白盒抽象中，在接口限制了用户行为并确保了封装性的情况下，客户仍然可以通过继承对构件的实现细节进行修改。由于在白盒方式中实现细节对外界使完全可见的，因此可以对实现细节进行研究，以加深对该接口抽象含义的理解。

揭示实现细节的可控部分。这是一个由争议的概念，因为部分可见的实现细节可以是规约的一部分。一个完整的实现只需要保证，能被客户看见的那部分实现细节与抽象的接口规约一致即可。这是将规约实现的标准方式。

黑盒重用指仅仅依赖接口和规约来实现。相反，白盒重用指依赖于对具体实现细节的理解，通过接口来使用软件不见。

### 1.1.6 接口

接口是一个已命名的一组操作的集合。

- 构件的客户（通常是其他构件）通过这些访问点来使用构件提供的服务。
- 通常来说，构件在不同的访问点有多个不同的接口。每一个访问点会提供不同的服务，以迎合不同的客户需求。
- 强调构件接口规范的合约性非常重要，因为构件和它的客户是在互不知情的情况下分别独立开发的，是合约提供了保证两者成功交互的公共中间层。

### 1.1.7 显式语境依赖

在上文的构件定义中，构件除了要说明所提供的接口外，还要说明其需求。也就是说为了使构件正常地工作，必须说明其对部署环境的具体要求。这些要求被称为语境依赖。指的是构件组装和部署的语境，包括了定义组件规则的构件模型和定义组件部署、安装和激活狗则的构件平台。

### 1.1.8 构件的规模

构件设计者通常不会构造自给自足的构件，将所需的所有东西都打包进来，而是采取一种“最大化重用”的策略。为了避免在构件中重用实现那些次要的服务，设计师通常会只实现该构件的核心功能，然后重用其他所有的一切。

虽然最大化重用的思想有很多为人称道的优点，但是它也有一个潜在的缺点——语境依赖的爆炸性增长。构件会不断地演化，不同的部署环境提供不同的配置，多种版本会同时存在，在这样的情况下大量的语境依赖只会使构件称为众矢之的。语境依赖越多，能满足构件环境需求的客户构件就越少。总之，最大化重用降低了可用性。

## 1.2 标准化与规范化

一个东西越稳定，越容易被广泛接收，其成为某个构件的特殊需求的危险就越小。如果语境依赖能够被广泛支持，就不是什么缺点。

### 1.2.1 通用市场与专业市场

如果要定制一种覆盖所有领域、有广泛市场的标准，就有必须区分面向通用市场与面向专业市场的两种标准。

- 通用市场覆盖了多数甚至全部不同的市场领域，它对所有或绝大多数的客户和生产商都有影响。
- 专业市场往往只限于某个特定的领域，相对来说影响比较小。

通用市场的标准化是非常困难的。如果有一项服务几乎和所有人都相关，那么它就得满足所有人的需求。

令人吃惊的是，专业市场的标准化与通用市场同样艰辛，虽然原因各不相同。由于专业市场中设计的人相对较少，所以比较容易形成一种折中的方案。

### 1.2.2 标准的构件体系与规范化

# 2 构件的布线标准

“布线”用于连接电子构件。

## 2.1 布线标准从何而来

由于过程的交互为进程边界所限，所以操作系统支持多种多样的进程间通信（Internet Process Connection，IPC）机制，典型的例子有文件、套接字（socket）及共享内存。除了BSD-UNIX套接字外，这些机制都不能跨平台移植。

IPC机制的一个共同的优势：它们可以很容易地被扩展到网络甚至是因特网上。这是传统进程模型的直接后果。在这个传统进程模型中，每个进程产生了一个幻想，就好像一个共享的物理主机上每个进程都拥有单独的虚拟机。

RPC的设想是在本地被调用者和远程调用者两端都使用指代（stub）。调用者使用严格的本地调用约定，就像调用了一个本地被调用者，实际上，却调用了一个本地指代来编排（串行化）参数，并把它们发送到远端。在远端，另一个指代接收参数，并还原（反串行化）参数，然后调用真正的被调用者。和调用者一样，被调用者的过程本身也要遵循本地调用约定，并且不知道自己被远程调用了。编排和还原过程负责转化数据值，将它们从本地表示转化为网络格式，然后再转化为远端表示。通过这种方法，格式的差异等被跨越了。

分布式计算环境（DCE）是OSF（Open Software Foundation，Open Group的一部分）的一个标准，它是在跨越异构平台上实现RPC机制的最重要的服务。在另一个极端，轻量RPC变化能被用来处理单机上的IPC问题。例如，Windows支持跨进程的轻量RPC；DCOM出现后，可以支持不同季期间的完全RPC。DCF也通过对每个服务附加主版本号来支持版本控制。客户可以指定它们想要版本的服务。

潜在的透明性既是RPC的优点，同时也是其负担。因为它隐藏了本地调用、进程间调用及机器间调用的很重要的代价上的差异。在大多数当前的体系结构上，进程间调用比本地调用慢10~1000倍，而机器间调用比进程间调用慢10~10000倍。

接口定义语言（Interface Definition Language，IDL），保证了不同环境下过程调用语义的一致性。对每一个可以被远程调用的过程，IDL指定了参数的数目、传递模式和类型，以及可能的返回值的类型。为了确保跨及其边界的通信正常工作，所有的IDL都必须固定基本类型的范围，例如指定整数是32位的二进制补码值（二进制的补码表示是一种以二进制形式表示负数的数学方案）。

过程调用及它们的二进制调用约定提供了一个良好证明的“布线”标准。但是它们还不能直接支持对象所需要的远程方法调用。如果和动态链接库（Dynamic Link Library，DLL）结合起来，远程过程调用就会在构件“布线”形成一个有用的基础的过程中更进一步。服务可以通过名字（DLL的名字）来定位，并被动态地绑定（不仅在编译时刻），而且服务可以是远程的。今天，Web服务似乎已成为事实上的否见布线标准。

## 2.2 从过程到对象

